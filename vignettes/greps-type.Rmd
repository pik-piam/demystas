---
title: "greps-type functions in demystas"
author: "Atreya Shankar"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette  
vignette: >
  %\VignetteIndexEntry{greps-type functions in demystas}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style>
    body {
          max-width: 800px;
          margin: auto;
          padding: 1em;
          line-height: 20px; 
    }
</style>

```{r set-options, include = FALSE, cache=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

greps-style functions form a key aspect of the `demystas` package. These functions assist with matching vectors of strings or keywords in order to deliver the best possible matchings. The three greps-style functions that we offer are:

1. `greps`: sequential string mapping
2. `grepsParallel`: parallel string mapping for large vectors
3. `grepsAbb`: sequential abbrevation to complete word mapping

## 1. `greps` function

### Basic functionality

Assume we have two vectors containing strings, here `x` and `y`.These vectors are included in the `/inst/extdata` directory of this R package and can be accessed as such:

```{r, echo=TRUE, eval=TRUE}
x <- read.csv(system.file("extdata", "sample1.csv", package = "demystas"), stringsAsFactors = FALSE)[337:347,1]

y <- read.csv(system.file("extdata", "sample2.csv", package = "demystas"), stringsAsFactors = FALSE)[29:35,1]
```

`x` shows an excerpt of input REMIND data from the European Energy datasheets. `y` represents an excerpt of REMIND model output. Our goal is to create some mappings from `x` to `y` in order to compare parameters and conduct validations. 

Here is what `x` and `y` look like:

```{r, echo=FALSE, results='asis'}
new <- data.frame(matrix(ncol = 2, nrow = 0))
new[1:length(x),1] <- x
new[1:length(y),2] <- y
names(new) <- c("x", "y")
knitr::kable(new)
```

Here, we can see keywords in `x` are separated by the character `"."` and keywords in `y` are separated by the character `"|"`. We can input these parameters into the `greps` function as regex-style expressions.

```{r, echo=TRUE, eval = FALSE}
test <- demystas::greps(x, y, sepx = "\\.", sepy = "\\|")
```

The functions produces a list with 2 matrices. The first matrix contains mappings from `x` to `y` and the second contains the respective matching scores. Take a look:

```{r, echo=FALSE, results='hide'}
test <- demystas::greps(x, y, sepx = "\\.", sepy = "\\|")
```
```{r, echo=TRUE, eval = FALSE, results='markup'}
View(test[[1]])
```
```{r, echo=FALSE, results='asis'}
knitr::kable(test[[1]])
```
```{r, echo=TRUE, eval = FALSE, results='markup'}
View(test[[2]])
```
```{r, echo=FALSE, results='asis'}
knitr::kable(test[[2]])
```

With these results, a human could then begin parsing the data row-by-row in order to select truly relevant or similar mappings. This algorithm naturally cannot provide a complete solution for mapping purposes, but it narrows down the search space for a human to do the more "intelligent" work.

### Advanced functionality

The `greps` functions contains some parameters to tweak the matching process based on the user's perspective. Some of the key parameters are:

1. `limitWord`: a numerical threshold greater than or equal to 0 for entire keyword matching
2. `limitChar`: a numerical threshold between 0 and 1 for string subset-based matching
3. `booster`: a numerical threshold which boosts the score of well-matched sub-strings
4. `wordIgnore`: a character vector of strings which should be ignored for the matching process

We will briefly go through `limitWord` and `limitChar`.

#### a. `limitWord`

As per the previous example, if we want to filter keywords which have a matching score greater than `0.15`, we can execute the following:

```{r, echo=TRUE, eval = FALSE}
test <- demystas::greps(x, y, sepx = "\\.", sepy = "\\|", limitWord = 0.15)
```
```{r, echo=FALSE, results='hide'}
test <- demystas::greps(x, y, sepx = "\\.", sepy = "\\|", limitWord = 0.15)
```
```{r, echo=TRUE, eval = FALSE, results='markup'}
View(test[[1]])
```
```{r, echo=FALSE, results='asis'}
knitr::kable(test[[1]])
```

Here, we see a smaller matrix of matchings with matching scores below or equal to 0.15 removed. This might be useful for filtering purposes.

#### b. `limitChar`

We can also notice that the bulk of the matchings occur because `Xport` in `x` is a case-insensitive subset of `Exports` in `y`. If we increase the value of `limitChar` to a large value like `0.9`, then `Xport` will no longer match to `Exports` since it does match more than 90% of its own characters.

```{r, echo=TRUE, eval = FALSE}
test <- demystas::greps(x, y, sepx = "\\.", sepy = "\\|", limitWord = 0.15, limitChar = 0.9)
```
```{r, echo=FALSE, results='hide'}
test <- demystas::greps(x, y, sepx = "\\.", sepy = "\\|", limitWord = 0.15, limitChar = 0.9)
```
```{r, echo=TRUE, eval = FALSE, results='markup'}
View(test[[1]])
```
```{r, echo=FALSE, results='asis'}
knitr::kable(test[[1]])
```

Here, we can see that there are no matchings altogether. This is because of our `limitChar` parameter being set too high. We can naturally reduce this parameter until we achieve more appropriate matchings.

The key idea of this parameter is to be able to omit non-meaningful matchings such as eg. `pe` being matched to `shape`; but allowing meaningful matchings of eg. `Xport` to `Exports`.

## 2. `grepsParallel` function

This function has the exact same functionalities as the `greps` function, except it can be executed in a parallel manner instead of a sequential manner. This is particularly useful for conducting keyword mappings on large vectors sets by reducing the time required for computation. Naturally, this is also useful for execution on a cluster.

The only additional parameter here is `noCores`, where the user specifies the number of cores to be used for parallel computation.

As a simple example, consider the two following vectors `x` and `y`:

```{r, echo=TRUE, eval=FALSE}
x <- read.csv(system.file("extdata", "sample1.csv", package = "demystas"), stringsAsFactors = FALSE)[1:100,1]

y <- read.csv(system.file("extdata", "sample2.csv", package = "demystas"), stringsAsFactors = FALSE)[1:300,1]
```

To match the keywords through our `greps` functions, we need to process 100 x 300 x 2 = 60,000 cases.

```{r, echo=TRUE, eval=FALSE}
test1 <- demystas::greps(x, y, sepx = "\\.", sepy = "\\|", limitWord = 0.1, limitChar = 0.5)

test2 <- demystas::grepsParallel(x, y, noCores = 4, sepx = "\\.", sepy = "\\|", limitWord = 0.1, limitChar = 0.5)
```
```{r, echo=FALSE, results='asis'}
new <- data.frame(matrix(ncol = 3, nrow = 0))
new[1,1] <- "84.441s"
new[1,2] <- "18.761s"
new[1,3] <- 84.441/18.761
names(new) <- c("greps", "grepsParallel", "speedRatio (par:seq)")
knitr::kable(new)
```

In this case given `x` and `y`, we can see that the `grepsParallel` function is ~4.5 times faster than the corresponding `greps` function.

Below, we plotted the execution time required for the sequential `greps` algorithm (red) against that of the parallel `grepsParallel` algorithm (blue). 

We essentially kept `x` at its maximum length and increased the length of `y` incrementally. Here, we can see that the sequential algorithm performs slightly better than the parallel algorithm until ~30,000 matching cases, After this, significant improvements in execution time manifest for the parallel algorithm. 

```{r echo=FALSE, out.width='70%', fig.align='center'}
knitr::include_graphics('./seqVparTime.png')
```

This can also be visualized by the speed ratio (black) of the parallel algorithm compared to the sequential algorithm. The benefits of the parallel algorithm appear to manifest at around ~30,000 matching cases. This is of course a subjective analysis; and the exact results would vary depending on the exact components of `x` and `y`.

```{r echo=FALSE, out.width='70%', fig.align='center'}
knitr::include_graphics('./seqVparSpeed.png')
```

### 3. `grepsAbb` function

The `grepsAbb` function essentially maps abbreviations to whole words using a logical mapping alogrithm. A useful example could be mapping non-ISO3 country abbreviations to country names. For these cases, there is no standard to map abbreviations to words, and therefore we could use the `grepsAbb` algorithm.

Here, we consider the following datasets:

```{r, echo=TRUE, eval=TRUE}
abb <- read.csv(system.file("extdata", "sample4.csv", package = "demystas"), stringsAsFactors = FALSE)[,1]

words <- read.csv(system.file("extdata", "sample3.csv", package = "demystas"), stringsAsFactors = FALSE)[,1]
```
```{r, echo=FALSE, results='asis'}
new <- data.frame(matrix(ncol = 2, nrow = 0))
new[1:length(abb),1] <- abb
new[1:length(words),2] <- words
names(new) <- c("abb", "words")
knitr::kable(new)
```

We will now apply the algorithm as below. The result will be a matrix of possible matchings.

```{r, echo=TRUE, eval = TRUE, results='hide'}
test <- demystas::grepsAbb(abb, words)
```
```{r, echo=FALSE, results='asis'}
knitr::kable(test)
```

This matrix narrows down the mappings, allowing the human to perform the remaining "intelligent" selections to complete the mapping.
